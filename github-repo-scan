#!/usr/bin/env ruby

#!/usr/bin/env ruby

require 'ostruct'
require 'tmpdir'

require 'graphql/client'
require 'graphql/client/http'
require 'slop' # option parsing

# Wrap up the client and schema details to make accessing the GitHub graphQL
# api a little easier.
#
# query_string = <--EOQL
# EOQL
# q   = GitHubQL.parse(query_string)
# res = GitHubQL.query(q, {})
#
module GitHubQL
  class Query
    def self.parse(qtext)
      GitHubQL.parse(qtext)
    end
  end

  def self.github_pat
    return @github_pat if @github_pat
    raise "GITHUB_PAT not set" unless ENV.key?('GITHUB_PAT') && !ENV['GITHUB_PAT'].nil? && !ENV['GITHUB_PAT'].empty?
    @github_pat = ENV['GITHUB_PAT']
  end

  def self.http
    return @http if @http

    unless ENV.key?('GITHUB_PAT') && !ENV['GITHUB_PAT'].nil? && !ENV['GITHUB_PAT'].empty?
      raise "GITHUB_PAT not set"
    end
    @http = ::GraphQL::Client::HTTP.new('https://api.github.com/graphql') do
      # def headers(context) { "Authorization" => "Bearer #{github_pat}" }
      def headers(context) { "Authorization" => "Bearer #{ENV['GITHUB_PAT']}" }
      end
    end
  end

  def self.schema
    return @schema if @schema

    schema_file = File.join(Dir.tmpdir, "github.schema.json")
    unless File.file? schema_file
      puts "Dumping schema to #{schema_file.inspect}"
      ::GraphQL::Client.dump_schema(http, schema_file)
    end
    @schema = ::GraphQL::Client.load_schema(schema_file)
  rescue
    FileUtils.rm_rf schema_file
  end

  def self.client
    @client ||= ::GraphQL::Client.new(schema: schema, execute: http)
  end

  def self.query(...)
    client.query(...)
  end

  def self.parse(...)
    client.parse(...)
  end

  def self.with_pagination(query, page_on_field, after_var, variables={})
    Enumerator.new do |yielder|
      response = query(query, variables: variables).data.result
      response.send(page_on_field).nodes.each { |node| yielder << node }

      page_info = response.send(page_on_field).page_info
      while page_info.has_next_page != false
        cursor = page_info.end_cursor
        variables[after_var] = cursor
        response = query(query, variables: variables).data.result
        response.send(page_on_field).nodes.each { |node| yielder << node }
        page_info = response.send(page_on_field).page_info
      end
    end
  end

  def self.get_connected(query, node, page_on_field, after_var)
    Enumerator.new do |yielder|
      page_on = node.send(page_on_field)
      page_on.nodes.each { |node| yielder << node }
      if page_on.page_info.has_next_page
        variables = {
          id: node['id'],
        }
        variables[after_var] = page_on.page_info.end_cursor,
        nodes << with_pagination(query, page_on_field, after_var, variables: variables)
      end
    end
  end

end # GitHubQL

RepoQuery = GitHubQL.parse <<-GRAPHQL
  query ($repoEndCursor: String, $repoFirst: Int=10, $filePath: String="Jenkinsfile") {
    result: organization(login: "fac") {
      repositories(first: $repoFirst, after: $repoEndCursor) {
        pageInfo {
          hasNextPage
          endCursor
        }
        totalCount
        nodes {
            name
            nameWithOwner
            isArchived
            defaultBranch: defaultBranchRef {
            target {
                ... on Commit {
                authoredDate
                author {
                    name
                    email
                }
                oid
                file(path: $filePath) {
                    name
                    path
                    type
                    object {
                    ... on Blob {
                        id
                        text
                    }
                  }
                }
              }
            }
            name
          }
        }
      }
    }
  }
GRAPHQL

class GitHubRepoScan
  VERSION = "v0.1.0"

  def initialize
    @opts = nil
  end

  def exit_usage!(msg = '')
    puts msg if msg != ''
    puts @opts
    exit 1
  end

  def main
    @opts = Slop.parse do |opt|
      opt.banner = "usage: #{$0} [ACTION] [OPTIONS]"

      opt.bool    '--archived',     'Include archived repos in the search'
      opt.bool    '--all',          'Include all repos, don\'t filter by archive or path existing'
      opt.integer '--text-context', '-C', 'Lines of files context to show', default: 10
      opt.bool    '--repo-divider', 'Show repo divider line in cat', default: true
      opt.bool    '--repo-prefix',  'Prefix lines with repo name in cat', default: true
      opt.string  '--path',         'File path in the repo to scan', default: 'README.md'
      opt.string  '--grep',         'File contents match this regex', default: ''
      opt.string  '--grep-exclude', 'File contents do not match this regex', default: ''
      opt.bool    '--long', '-l'    'Long list format'
      opt.bool    '--count',        'Show count on repo matches and total at the end'
      opt.bool    '--task-list',    'Markdown task list format list'

      opt.on '--version', 'print the version' do
        puts GitHubRepoScan::VERSION
        exit
      end
    end

    exit_usage! 'No action given' if @opts.arguments.size != 1
    act = @opts.arguments[0].to_sym
    exit_usage! "Unknown action: #{act}" unless self.respond_to? act
    self.send(act)
  end

  def json
    res = GitHubQL.query(RepoQuery, variables: { repoFirst: 1 })
    puts JSON.pretty_generate(res.to_h)
  end

  def total
    res = GitHubQL.query(RepoQuery, variables: { repoFirst: 1 })
    puts "Total Count: #{res.data.result.repositories.total_count}"
  end

  def ls(...)
    list(...)
  end

  def list
    res = GitHubQL.query(RepoQuery, variables: { repoFirst: 1 }).data.result
    total_count = res.repositories.total_count.to_i

    c = 0
    repo_query(repoFirst: 100) do |repo|
      c = c + 1
      puts list_line(c, repo, total_count: total_count)
    end
    puts("#{c} repos") if @opts[:count]
  end

  private def list_line(c, repo, total_count: 0)
    sha      = repo.default_branch.target.oid
    fname    = repo.default_branch.target&.file&.path # includes name
    authDate = repo.default_branch.target&.authored_date 
    authName = repo.default_branch.target&.author&.name
    arch     = repo.is_archived ? "ARCHIVED " : ""
    line = if @opts[:task_list]
      "* [ ] "
    elsif @opts[:count]
      #w = total_count.to_s.size
      #w = 2 if w < 2
      #"%#{w}d " % c
      "%2d " % c
    else
      ""
    end
    #line += "#{repo.name_with_owner} #{arch}"
    line += "%-20s %s" % [repo.name_with_owner, arch]
    if @opts[:long]
      line += " #{fname} #{sha[0..8]} #{authDate} #{authName}"
    end
    line
  end

  # cat contents of repos path to stdout
  def cat
    repo_query(repoFirst: 10) do |repo|
      name  = repo.name_with_owner
      sha   = repo.default_branch.target.oid
      fname = repo.default_branch.target.file.path # includes name
      puts "==> #{name} #{fname}@#{sha} <==============================" if @opts[:repo_divider]
      text = repo.default_branch.target&.file&.object&.text
      unless text
        puts "<no match>"
        next
      end
      prefix = @opts[:repo_prefix] ? "#{name}: " : ""
      puts prefix + text.split(/\n/).first(@opts[:text_context]).join("\n#{prefix}")
    end
  end

  # Run and page through the RepoQuery, filter out repos that don't match the
  # repo_filter, run the given block on each repo that does.
  # Traps errors in that block, outputs error and the raw json for the
  # offending repo.
  private def repo_query(**kwargs, &block)
    vars  = { filePath: @opts[:path] }.merge(kwargs)
    repos = GitHubQL.with_pagination(RepoQuery, :repositories, 'repoEndCursor', vars)
    repos.each do |repo|
      next unless @opts[:all] || repo_filter(repo)
      block.call repo
    #rescue StandardError => err
    #  STDERR.puts "ERROR: #{err}"
    #  STDERR.puts JSON.pretty_generate(repo.to_h)
    end
  end

  # Given a repo, return true to include the repo, false to exclude
  private def repo_filter(repo)
    return false if !@opts[:all] && repo.is_archived && ! @opts[:archived] 
    return false if !@opts[:all] && repo&.default_branch&.target&.file.nil?
    text = repo.default_branch.target&.file&.object&.text
    unless @opts[:grep].empty?
      return false unless text
      return false unless text =~ /#{@opts[:grep]}/m
    end
    unless @opts[:grep_exclude].empty?
      return false unless text
      return false unless text !~ /#{@opts[:grep_exclude]}/m
    end
    true
  end
end

GitHubRepoScan.new.main
